<!-- This file defines the header to use when generating documentation for  -->
<!-- Pixel with Doxygen.                                                    -->
<html>
  <head>
    <!-- Import Google Icon Font -->
    <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Let the browser know that the website is optimized for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Pulley : Pix::Pulley::SPSCQueue&lt; Type &gt; Class Template Reference</title>
    <title>Pix::Pulley::SPSCQueue&lt; Type &gt; Class Template Reference</title>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/js/materialize.min.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="$sytlesheet" rel="stylesheet" type="text/css"/>
    <link href="pixel.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="DoxyFormat.js"></script>
  </head>
  <body class="site">
    <nav>
      <div class="nav-wrapper z-depth-1">
        <!-- All libraries are in the libraries/libname/ dir, and the main  -->
        <!-- index.html is at ../../                                        -->
        <a href="../../index.html" class="brand-logo center">
          <img border="0" src="../../images/PixelTechnologiesLogoLight.png" class="logo">
        </a>
        <ul class="left hide-on-med-and-down">
          <li><a href="#" data-activates="slide-out" class="button-collapse"><i class="material-icons">menu</i></a></li>
          <li><a href="../../GettingStarted.html">GettingStarted</a></li>
          <li><a href="../../Guides.html">Guides</a></li>
          <li><a href="../../Libraries.html">Libraries</a></li>
        </ul>
        <form>
          <div class="input-field right">
            <input id="search" type="search" placeholder="Search" required>
            <label for="search"><i class="material-icons">search</i></label>
            <i class="material-icons">close</i>
          </div>
        </form>
      </div>
    </nav>
    <!--div class="row">
      <div class="col s3 m3 l3">
      </div>
      <div class="col s6 m6 l6">
        <div class="card teal accent-4">
          <div class="card-action blue-text darken-4">
            <a href="index.html">Meta</a>
            <a href="files.html">Files</a>
          </div>
        </div>
      </div>
    </div-->
    <div id="top">
      <div id="content" class="site-content">
        <div class="row">
          <div class="col s0 m2 l3"> 
          </div>
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Pix</b></li><li class="navelem"><b>Pulley</b></li><li class="navelem"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPix_1_1Pulley_1_1SPSCQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pix::Pulley::SPSCQueue&lt; Type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html" title="The SPSCQueue is a single producer, single consumer queue, which does not use any locking...">SPSCQueue</a> is a single producer, single consumer queue, which does not use any locking, but rather uses atomic variables to allow concurrent pushing and popping from the queue.  
 <a href="classPix_1_1Pulley_1_1SPSCQueue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SPSCQueue_8hpp_source.html">SPSCQueue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3e8a35a6fa23ddffea3446b8b116fb7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e8a35a6fa23ddffea3446b8b116fb7e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a3e8a35a6fa23ddffea3446b8b116fb7e">ValueType</a> = Type</td></tr>
<tr class="memdesc:a3e8a35a6fa23ddffea3446b8b116fb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the types of the elements in the queue. <br /></td></tr>
<tr class="separator:a3e8a35a6fa23ddffea3446b8b116fb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd553561468244bbedb56c01564c8fcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd553561468244bbedb56c01564c8fcb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abd553561468244bbedb56c01564c8fcb">AtomicInternalType</a> = std::size_t</td></tr>
<tr class="memdesc:abd553561468244bbedb56c01564c8fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type stored in the atomic wrapper. <br /></td></tr>
<tr class="separator:abd553561468244bbedb56c01564c8fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b4659dd8b64981baec0e3de4db21d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60b4659dd8b64981baec0e3de4db21d6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a60b4659dd8b64981baec0e3de4db21d6">AtomicType</a> = std::atomic&lt; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abd553561468244bbedb56c01564c8fcb">AtomicInternalType</a> &gt;</td></tr>
<tr class="memdesc:a60b4659dd8b64981baec0e3de4db21d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of the atomics which are being used. <br /></td></tr>
<tr class="separator:a60b4659dd8b64981baec0e3de4db21d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53b038942cc15794adc752cb7d43c1bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53b038942cc15794adc752cb7d43c1bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a53b038942cc15794adc752cb7d43c1bb">SPSCQueue</a> (const <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:a53b038942cc15794adc752cb7d43c1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor &ndash; we delete it to disable copying of the queue. <br /></td></tr>
<tr class="separator:a53b038942cc15794adc752cb7d43c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150d09a90966433934cdcaded8eeddb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a150d09a90966433934cdcaded8eeddb3">operator=</a> (const <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:a150d09a90966433934cdcaded8eeddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator &ndash; we delete it to disable the assigning of a queue to another.  <a href="#a150d09a90966433934cdcaded8eeddb3">More...</a><br /></td></tr>
<tr class="separator:a150d09a90966433934cdcaded8eeddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ac101bb6e14a6ddbd3c70cb2747945"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a14ac101bb6e14a6ddbd3c70cb2747945">SPSCQueue</a> (<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a14ac101bb6e14a6ddbd3c70cb2747945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor &ndash; allows the Queue to be moved.  <a href="#a14ac101bb6e14a6ddbd3c70cb2747945">More...</a><br /></td></tr>
<tr class="separator:a14ac101bb6e14a6ddbd3c70cb2747945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf582392c947a203e8639c8c6fe9bdfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abf582392c947a203e8639c8c6fe9bdfd">~SPSCQueue</a> ()</td></tr>
<tr class="memdesc:abf582392c947a203e8639c8c6fe9bdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor &ndash; cleans up anything which is still in the queue before destruction.  <a href="#abf582392c947a203e8639c8c6fe9bdfd">More...</a><br /></td></tr>
<tr class="separator:abf582392c947a203e8639c8c6fe9bdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb86cdae2dac57e0f6d5fa434caab5a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a3e8a35a6fa23ddffea3446b8b116fb7e">ValueType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#acb86cdae2dac57e0f6d5fa434caab5a5">front</a> ()</td></tr>
<tr class="memdesc:acb86cdae2dac57e0f6d5fa434caab5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the (non-const) first element in the queue, wrapped in an ErrorOr&lt;&gt;, i.e ErrorOr&lt;ValueType&amp;&gt;.  <a href="#acb86cdae2dac57e0f6d5fa434caab5a5">More...</a><br /></td></tr>
<tr class="separator:acb86cdae2dac57e0f6d5fa434caab5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bc028c6fecc420e08fc53f9d6f6986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; const <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a3e8a35a6fa23ddffea3446b8b116fb7e">ValueType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a13bc028c6fecc420e08fc53f9d6f6986">front</a> () const </td></tr>
<tr class="memdesc:a13bc028c6fecc420e08fc53f9d6f6986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the (const) first element in the queue, wrapped in an ErrorOr&lt;&gt;, i.e ErrorOr&lt;const ValueType&amp;&gt;.  <a href="#a13bc028c6fecc420e08fc53f9d6f6986">More...</a><br /></td></tr>
<tr class="separator:a13bc028c6fecc420e08fc53f9d6f6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd36215febce930e37db2e4dca1751fc"><td class="memTemplParams" colspan="2">template&lt;typename... ElementArgs&gt; </td></tr>
<tr class="memitem:acd36215febce930e37db2e4dca1751fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#acd36215febce930e37db2e4dca1751fc">push</a> (ElementArgs &amp;&amp;...elemArgs)</td></tr>
<tr class="memdesc:acd36215febce930e37db2e4dca1751fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes an element onto the back of the queue.  <a href="#acd36215febce930e37db2e4dca1751fc">More...</a><br /></td></tr>
<tr class="separator:acd36215febce930e37db2e4dca1751fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23aad11141f06569cf60f221f605e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#aa23aad11141f06569cf60f221f605e7c">pop</a> ()</td></tr>
<tr class="memdesc:aa23aad11141f06569cf60f221f605e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the front element from the queue, if the queue is not empty.  <a href="#aa23aad11141f06569cf60f221f605e7c">More...</a><br /></td></tr>
<tr class="separator:aa23aad11141f06569cf60f221f605e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9326ac75b5993b0ada3b624b00a9a082"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9326ac75b5993b0ada3b624b00a9a082"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a9326ac75b5993b0ada3b624b00a9a082">empty</a> () const </td></tr>
<tr class="memdesc:a9326ac75b5993b0ada3b624b00a9a082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no elements in the queue. <br /></td></tr>
<tr class="separator:a9326ac75b5993b0ada3b624b00a9a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0121ff9d349e8b4f4c805ea12637928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0121ff9d349e8b4f4c805ea12637928"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#af0121ff9d349e8b4f4c805ea12637928">full</a> () const </td></tr>
<tr class="memdesc:af0121ff9d349e8b4f4c805ea12637928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is no space for more elements in the queue. <br /></td></tr>
<tr class="separator:af0121ff9d349e8b4f4c805ea12637928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a2e0907b35fbdf9379679aa663fe86"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a67a2e0907b35fbdf9379679aa663fe86">sizeEstimate</a> () const </td></tr>
<tr class="memdesc:a67a2e0907b35fbdf9379679aa663fe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (approximate) number of elements currently in the queue.  <a href="#a67a2e0907b35fbdf9379679aa663fe86">More...</a><br /></td></tr>
<tr class="separator:a67a2e0907b35fbdf9379679aa663fe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac544cb60c101c0c4908d9f7841d93806"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a>&lt; Type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#ac544cb60c101c0c4908d9f7841d93806">create</a> (<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abd553561468244bbedb56c01564c8fcb">AtomicInternalType</a> maxSize)</td></tr>
<tr class="memdesc:ac544cb60c101c0c4908d9f7841d93806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new queue, with an upper bound for the number of elements in the queue.  <a href="#ac544cb60c101c0c4908d9f7841d93806">More...</a><br /></td></tr>
<tr class="separator:ac544cb60c101c0c4908d9f7841d93806"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a699ddb4f43c77655f930d7deddb64126"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a699ddb4f43c77655f930d7deddb64126">SPSCQueue</a> (<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abd553561468244bbedb56c01564c8fcb">AtomicInternalType</a> maxSize, <a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> &amp;error)</td></tr>
<tr class="memdesc:a699ddb4f43c77655f930d7deddb64126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit constructor &ndash; intializes the upper bound for the queue, and allocates suffcient memory fo storage for the upper bound.  <a href="#a699ddb4f43c77655f930d7deddb64126">More...</a><br /></td></tr>
<tr class="separator:a699ddb4f43c77655f930d7deddb64126"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a668669afc3fa7c9a928cdc555272e705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a668669afc3fa7c9a928cdc555272e705"></a>
<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abd553561468244bbedb56c01564c8fcb">AtomicInternalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a668669afc3fa7c9a928cdc555272e705">Capacity</a></td></tr>
<tr class="memdesc:a668669afc3fa7c9a928cdc555272e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max capacity for the queue. <br /></td></tr>
<tr class="separator:a668669afc3fa7c9a928cdc555272e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61c37abc0f419c7c8d5cf6bb43e34e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab61c37abc0f419c7c8d5cf6bb43e34e9"></a>
<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a3e8a35a6fa23ddffea3446b8b116fb7e">ValueType</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#ab61c37abc0f419c7c8d5cf6bb43e34e9">Elements</a></td></tr>
<tr class="memdesc:ab61c37abc0f419c7c8d5cf6bb43e34e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to allocated memory block of queue elements. <br /></td></tr>
<tr class="separator:ab61c37abc0f419c7c8d5cf6bb43e34e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af88214171530ed2e9e9335dbac2ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0af88214171530ed2e9e9335dbac2ca7"></a>
<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a60b4659dd8b64981baec0e3de4db21d6">AtomicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a0af88214171530ed2e9e9335dbac2ca7">ReadIndex</a></td></tr>
<tr class="memdesc:a0af88214171530ed2e9e9335dbac2ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next element to read. <br /></td></tr>
<tr class="separator:a0af88214171530ed2e9e9335dbac2ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0972daddcc8e77c019fb5d274be7ab1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0972daddcc8e77c019fb5d274be7ab1c"></a>
<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a60b4659dd8b64981baec0e3de4db21d6">AtomicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a0972daddcc8e77c019fb5d274be7ab1c">WriteIndex</a></td></tr>
<tr class="memdesc:a0972daddcc8e77c019fb5d274be7ab1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next element to write. <br /></td></tr>
<tr class="separator:a0972daddcc8e77c019fb5d274be7ab1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type&gt;<br />
class Pix::Pulley::SPSCQueue&lt; Type &gt;</h3>

<p>The <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html" title="The SPSCQueue is a single producer, single consumer queue, which does not use any locking...">SPSCQueue</a> is a single producer, single consumer queue, which does not use any locking, but rather uses atomic variables to allow concurrent pushing and popping from the queue. </p>
<p>It is a FIFO container, where new elements are pushed onto the back of the container, and popped from the front. This implementation can store a fixed number of elements, which is user defined. The queue follows a similar interface to the <code>std::queue</code> , with <code><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#acd36215febce930e37db2e4dca1751fc" title="Pushes an element onto the back of the queue. ">push()</a></code> and <code><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#aa23aad11141f06569cf60f221f605e7c" title="Removes the front element from the queue, if the queue is not empty. ">pop()</a></code> being the interfaces through which elements are added/removed to/from the queue respectively.</p>
<p>The creation of the queue is non-standard, to support the ErrorOr&lt;&gt; wrapper for the case that the memory for the queue cannot be allocated:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a queue of 10000 elements:</span></div>
<div class="line"><span class="keyword">auto</span> queue = <a class="code" href="classPix_1_1Pulley_1_1SPSCQueue.html#ac544cb60c101c0c4908d9f7841d93806">SPSCQueue&lt;int&gt;::create</a>(10000);</div>
</div><!-- fragment --><p>Trying to <code><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#aa23aad11141f06569cf60f221f605e7c" title="Removes the front element from the queue, if the queue is not empty. ">pop()</a></code> from an empty queue returns an ErrorOr&lt;ValueType*&gt;, in the error state, which will need to be handled. The same is true when trying to access the front element in the queue when the queue is empty. Make sure the error case is handled &ndash; the overhead of this is very small and can really help with debugging, and in release code is almost non-existant.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> queue = <a class="code" href="classPix_1_1Pulley_1_1SPSCQueue.html#ac544cb60c101c0c4908d9f7841d93806">SPSCQueue&lt;int&gt;::create</a>(1000);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> elemPtr = queue-&gt;front()) {</div>
<div class="line">  elemPtr-&gt;doWork();</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> err = queue-&gt;pop())</div>
<div class="line">    <span class="comment">// Handle error ...</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  logAllUnhandledTypeErrors(std::move(elem.takeError()), std::cout, </div>
<div class="line">                            <span class="stringliteral">&quot;Access errors:&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Trying to push to the queue returns false if the queue is full. This error is not as serious as trying to access invalid memory (<code><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#acb86cdae2dac57e0f6d5fa434caab5a5" title="Returns a pointer to the (non-const) first element in the queue, wrapped in an ErrorOr<>, i.e ErrorOr<ValueType&>. ">front()</a></code>) or trying to remove non-existent elements (<code><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#aa23aad11141f06569cf60f221f605e7c" title="Removes the front element from the queue, if the queue is not empty. ">pop()</a></code>), so we just return a bool for the result of the operation:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> queue = <a class="code" href="classPix_1_1Pulley_1_1SPSCQueue.html#ac544cb60c101c0c4908d9f7841d93806">SPSCQueue&lt;int&gt;::create</a>(10);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Potential usage:</span></div>
<div class="line"><span class="keywordflow">while</span> (!queue-&gt;push(4)) {</div>
<div class="line">  <span class="comment">// Spin if queue full ...</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Possible other usage:</span></div>
<div class="line"><span class="comment">// Let the caller take action based on the result:</span></div>
<div class="line"><span class="keywordflow">return</span> queue-&gt;push(4);</div>
</div><!-- fragment --><p>We do not support reading from the front of the queue by passing in a reference. To do so would require passing in an ErrorOr&lt;ValueType&amp;&gt; element, and while it's possible to create such an object, the syntax would not be as nice as is the case for the implemented ErrorOr&lt;ValueType*&gt; element.</p>
<p>Lastly, one might be concerned about the use of <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> and ErrorOr&lt;&gt; typed for failure cases and the implications on performance. Benchmarking has shown that the performance is more than sufficient, and that the inclusion of the error types has virtually no overhead, especially when compiled for release. They have, however, made debugging simpler and allowed error messages to be nicely formatted in debug mode.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the elements in the queue. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a14ac101bb6e14a6ddbd3c70cb2747945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; Type &gt;::<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a>&lt; Type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor &ndash; allows the Queue to be moved. </p>
<p>The queue is like a unique_ptr &ndash;it can be moved, but not copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The queue to move into this queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf582392c947a203e8639c8c6fe9bdfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; T &gt;::~<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor &ndash; cleans up anything which is still in the queue before destruction. </p>

</div>
</div>
<a class="anchor" id="a699ddb4f43c77655f930d7deddb64126"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; T &gt;::<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abd553561468244bbedb56c01564c8fcb">AtomicInternalType</a>&#160;</td>
          <td class="paramname"><em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit constructor &ndash; intializes the upper bound for the queue, and allocates suffcient memory fo storage for the upper bound. </p>
<p>If the queue cannot be created, the <code>error</code> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>The maximum number of elements the queue can hold. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The error to set if an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac544cb60c101c0c4908d9f7841d93806"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a>&lt; T &gt; &gt; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; T &gt;::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#abd553561468244bbedb56c01564c8fcb">AtomicInternalType</a>&#160;</td>
          <td class="paramname"><em>maxSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new queue, with an upper bound for the number of elements in the queue. </p>
<p>This returns an ErrorOr&lt;SPSCQueue&gt;, to allow error diagnostics on the queue in debug mode. This is the interface which must be used to create a queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>The maximum number of elements which can be in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb86cdae2dac57e0f6d5fa434caab5a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt;<a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a3e8a35a6fa23ddffea3446b8b116fb7e">ValueType</a>*&gt; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; Type &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the (non-const) first element in the queue, wrapped in an ErrorOr&lt;&gt;, i.e ErrorOr&lt;ValueType&amp;&gt;. </p>
<p>If the queue is empty, the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> object stores a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a>, which must be handled. </p>

</div>
</div>
<a class="anchor" id="a13bc028c6fecc420e08fc53f9d6f6986"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt;const <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html#a3e8a35a6fa23ddffea3446b8b116fb7e">ValueType</a>*&gt; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; Type &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the (const) first element in the queue, wrapped in an ErrorOr&lt;&gt;, i.e ErrorOr&lt;const ValueType&amp;&gt;. </p>
<p>If the queue is empty, the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> object stores a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a>, which must be handled. </p>

</div>
</div>
<a class="anchor" id="a150d09a90966433934cdcaded8eeddb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a>&amp; <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">SPSCQueue</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator &ndash; we delete it to disable the assigning of a queue to another. </p>

</div>
</div>
<a class="anchor" id="aa23aad11141f06569cf60f221f605e7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; Type &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the front element from the queue, if the queue is not empty. </p>
<p>If the queue is empty, then a <a class="el" href="classPix_1_1Pulley_1_1LogicError.html" title="Defines a base class for all logic related errors. ">LogicError</a> is returned specifying that an element is trying to be popped from an empty queue. </p>

</div>
</div>
<a class="anchor" id="acd36215febce930e37db2e4dca1751fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<div class="memtemplate">
template&lt;typename... ElementArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; Type &gt;::push </td>
          <td>(</td>
          <td class="paramtype">ElementArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>elemArgs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes an element onto the back of the queue. </p>
<p>If the queue is full, false is returned, otherwise true is returned to indicate success. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elemArgs</td><td>The arguements for constructing an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementArgs</td><td>The types of the arguements for constructing a new element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67a2e0907b35fbdf9379679aa663fe86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classPix_1_1Pulley_1_1SPSCQueue.html">Pix::Pulley::SPSCQueue</a>&lt; Type &gt;::sizeEstimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (approximate) number of elements currently in the queue. </p>
<p>Note the following:</p><ul>
<li>If called by the consumer (reader), then the size may be larger than what is returned (since the producer could have concurrently added elements).</li>
<li>If called by the producer (writer), the the size may be smaller than what is returned (since the consumer could have concurrently removed some elements).</li>
<li>If called from a thread which is not the producing or consming thread, then the behaviour is undefined. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/robclucas/Pixel/Software/Documentation/scripts/Pulley/Include/Pixel/Pulley/Queue/<a class="el" href="SPSCQueue_8hpp_source.html">SPSCQueue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- This file defines the footer to use when generating documentation      -->
<!-- for Pixel with Doxygen.                                                -->
<footer class="page-footer">
  <!--div class="container"-->
    <div class="row">
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
          <h5 class="blue-text text-darken-4">Footer Content</h5>
          <p class="blue-text text-darken-4">Organize footer content.</p>
        </div>
        <div class="right">
          <h5 class="blue-text text-darken-4">Links</h5>
        </div>
      </div>
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
    </div>
  <div class="footer-copyright">
    <div class="row">
      <div class="col s0 m2 l3">
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
          © 2016 Pixel Technologies, Ltd
        </div>
        <div class="right">
          <a class="grey-text text-lighten-4" href="#!">More Links</a>
        </div>
      </div>
      <div class="col s0 m2 l3">
      </div>
    </div>
  </div>
  <!--/div-->
</footer>
