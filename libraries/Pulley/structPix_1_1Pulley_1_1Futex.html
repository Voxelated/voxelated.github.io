<!-- This file defines the header to use when generating documentation for  -->
<!-- Pixel with Doxygen.                                                    -->
<html>
  <head>
    <!-- Import Google Icon Font -->
    <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Let the browser know that the website is optimized for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Pulley : Pix::Pulley::Futex&lt; AtomicWrapper &gt; Struct Template Reference</title>
    <title>Pix::Pulley::Futex&lt; AtomicWrapper &gt; Struct Template Reference</title>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/js/materialize.min.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="$sytlesheet" rel="stylesheet" type="text/css"/>
    <link href="pixel.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="DoxyFormat.js"></script>
  </head>
  <body class="site">
    <nav>
      <div class="nav-wrapper z-depth-1">
        <!-- All libraries are in the libraries/libname/ dir, and the main  -->
        <!-- index.html is at ../../                                        -->
        <a href="../../index.html" class="brand-logo center">
          <img border="0" src="../../images/PixelTechnologiesLogoLight.png" class="logo">
        </a>
        <ul class="left hide-on-med-and-down">
          <li><a href="#" data-activates="slide-out" class="button-collapse"><i class="material-icons">menu</i></a></li>
          <li><a href="../../GettingStarted.html">GettingStarted</a></li>
          <li><a href="../../Guides.html">Guides</a></li>
          <li><a href="../../Libraries.html">Libraries</a></li>
        </ul>
        <form>
          <div class="input-field right">
            <input id="search" type="search" placeholder="Search" required>
            <label for="search"><i class="material-icons">search</i></label>
            <i class="material-icons">close</i>
          </div>
        </form>
      </div>
    </nav>
    <!--div class="row">
      <div class="col s3 m3 l3">
      </div>
      <div class="col s6 m6 l6">
        <div class="card teal accent-4">
          <div class="card-action blue-text darken-4">
            <a href="index.html">Meta</a>
            <a href="files.html">Files</a>
          </div>
        </div>
      </div>
    </div-->
    <div id="top">
      <div id="content" class="site-content">
        <div class="row">
          <div class="col s0 m2 l3"> 
          </div>
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Pix</b></li><li class="navelem"><b>Pulley</b></li><li class="navelem"><a class="el" href="structPix_1_1Pulley_1_1Futex.html">Futex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="structPix_1_1Pulley_1_1Futex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pix::Pulley::Futex&lt; AtomicWrapper &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a> class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data.  
 <a href="structPix_1_1Pulley_1_1Futex.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Futex_8hpp_source.html">Futex.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Pix::Pulley::Futex&lt; AtomicWrapper &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structPix_1_1Pulley_1_1Futex.png" usemap="#Pix::Pulley::Futex&lt; AtomicWrapper &gt;_map" alt=""/>
  <map id="Pix::Pulley::Futex&lt; AtomicWrapper &gt;_map" name="Pix::Pulley::Futex&lt; AtomicWrapper &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a035f9bf595b6131cb3c6600fb9250350"><td class="memTemplParams" colspan="2">template&lt;typename ClockType , typename Duration  = ClockType::duration&gt; </td></tr>
<tr class="memitem:a035f9bf595b6131cb3c6600fb9250350"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a035f9bf595b6131cb3c6600fb9250350">Timepoint</a> = std::chrono::time_point&lt; ClockType, Duration &gt;</td></tr>
<tr class="memdesc:a035f9bf595b6131cb3c6600fb9250350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an alias for a general timepoint.  <a href="#a035f9bf595b6131cb3c6600fb9250350">More...</a><br /></td></tr>
<tr class="separator:a035f9bf595b6131cb3c6600fb9250350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07cd53ec450663072a844723526a7b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07cd53ec450663072a844723526a7b8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#ab07cd53ec450663072a844723526a7b8">AtomicType</a> = AtomicWrapper&lt; uint32_t &gt;</td></tr>
<tr class="memdesc:ab07cd53ec450663072a844723526a7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of the atomic variable after wrapping the uint32_t type. <br /></td></tr>
<tr class="separator:ab07cd53ec450663072a844723526a7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1ab014d2f7bd855dcc1c2bf2631ed37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1ab014d2f7bd855dcc1c2bf2631ed37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#af1ab014d2f7bd855dcc1c2bf2631ed37">Futex</a> (const <a class="el" href="structPix_1_1Pulley_1_1Futex.html">Futex</a> &amp;)=delete</td></tr>
<tr class="memdesc:af1ab014d2f7bd855dcc1c2bf2631ed37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor &ndash; deleted to enforce that a <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a> cannot be copied. <br /></td></tr>
<tr class="separator:af1ab014d2f7bd855dcc1c2bf2631ed37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423685a4f1392a60eaac6e4a11816423"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a423685a4f1392a60eaac6e4a11816423">Futex</a> (uint32_t initValue=0)</td></tr>
<tr class="memdesc:a423685a4f1392a60eaac6e4a11816423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit constructor &ndash; initializes the <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a>, usually using the default value provided.  <a href="#a423685a4f1392a60eaac6e4a11816423">More...</a><br /></td></tr>
<tr class="separator:a423685a4f1392a60eaac6e4a11816423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c75f21ae51f6b2584a360238a33d83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c75f21ae51f6b2584a360238a33d83"></a>
<a class="el" href="structPix_1_1Pulley_1_1Futex.html">Futex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a98c75f21ae51f6b2584a360238a33d83">operator=</a> (const <a class="el" href="structPix_1_1Pulley_1_1Futex.html">Futex</a> &amp;)=delete</td></tr>
<tr class="memdesc:a98c75f21ae51f6b2584a360238a33d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator &ndash; deleted to enfore that <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a> cannot be copied. <br /></td></tr>
<tr class="separator:a98c75f21ae51f6b2584a360238a33d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281bee84e0903cebd6f1a44c955b34eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a281bee84e0903cebd6f1a44c955b34eb">wait</a> (uint32_t expected, uint32_t waitMask=-1)</td></tr>
<tr class="memdesc:a281bee84e0903cebd6f1a44c955b34eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the thread to sleep if the state of the futex (its value) is the value given by expected.  <a href="#a281bee84e0903cebd6f1a44c955b34eb">More...</a><br /></td></tr>
<tr class="separator:a281bee84e0903cebd6f1a44c955b34eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c86e2a6b016d168f8cba47cfc424ab"><td class="memTemplParams" colspan="2">template&lt;typename ClockType , typename Duration  = ClockType::duration&gt; </td></tr>
<tr class="memitem:a78c86e2a6b016d168f8cba47cfc424ab"><td class="memTemplItemLeft" align="right" valign="top">FutexOpResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a78c86e2a6b016d168f8cba47cfc424ab">waitUntil</a> (uint32_t expected, <a class="el" href="structPix_1_1Pulley_1_1Futex.html#a035f9bf595b6131cb3c6600fb9250350">Timepoint</a>&lt; ClockType, Duration &gt; &amp;timeout, uint32_t waitMask=-1)</td></tr>
<tr class="memdesc:a78c86e2a6b016d168f8cba47cfc424ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="structPix_1_1Pulley_1_1Futex.html#a281bee84e0903cebd6f1a44c955b34eb" title="Puts the thread to sleep if the state of the futex (its value) is the value given by expected...">wait()</a>, but the additional maxTime parameter defines the maximum ammount of time a thread is allowed to block for (which is the absolute time (time_since_epoch).  <a href="#a78c86e2a6b016d168f8cba47cfc424ab">More...</a><br /></td></tr>
<tr class="separator:a78c86e2a6b016d168f8cba47cfc424ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa99ac4cbeb9b9a03d0a074181324d43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#aaa99ac4cbeb9b9a03d0a074181324d43">wake</a> (int count=std::numeric_limits&lt; uint32_t &gt;::max(), uint32_t wakeMask=-1)</td></tr>
<tr class="memdesc:aaa99ac4cbeb9b9a03d0a074181324d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up threads waiting on a the futex.  <a href="#aaa99ac4cbeb9b9a03d0a074181324d43">More...</a><br /></td></tr>
<tr class="separator:aaa99ac4cbeb9b9a03d0a074181324d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6560cf0f43b148001456335979d9dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e6560cf0f43b148001456335979d9dd"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2e6560cf0f43b148001456335979d9dd"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wake</b> (int count, uint32_t wakeMask)</td></tr>
<tr class="separator:a2e6560cf0f43b148001456335979d9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2ff5cef18317b82818fc1a1e42240561"><td class="memTemplParams" colspan="2">template&lt;typename ClockType , typename Duration  = ClockType::duration&gt; </td></tr>
<tr class="memitem:a2ff5cef18317b82818fc1a1e42240561"><td class="memTemplItemLeft" align="right" valign="top">FutexOpResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a2ff5cef18317b82818fc1a1e42240561">waitImpl</a> (uint32_t expected, <a class="el" href="structPix_1_1Pulley_1_1Futex.html#a035f9bf595b6131cb3c6600fb9250350">Timepoint</a>&lt; ClockType, Duration &gt; &amp;timeout, uint32_t waitMask=-1)</td></tr>
<tr class="memdesc:a2ff5cef18317b82818fc1a1e42240561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the implementation of the wait functionality.  <a href="#a2ff5cef18317b82818fc1a1e42240561">More...</a><br /></td></tr>
<tr class="separator:a2ff5cef18317b82818fc1a1e42240561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f0c654a54dbad27d0059f3665c5a3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae13f0c654a54dbad27d0059f3665c5a3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae13f0c654a54dbad27d0059f3665c5a3"><td class="memTemplItemLeft" align="right" valign="top">FutexOpResult&#160;</td><td class="memTemplItemRight" valign="bottom"><b>waitImpl</b> (uint32_t expected, <a class="el" href="structPix_1_1Pulley_1_1Futex.html#a035f9bf595b6131cb3c6600fb9250350">Timepoint</a>&lt; ClockType, Duration &gt; &amp;timeout, uint32_t waitMask)</td></tr>
<tr class="separator:ae13f0c654a54dbad27d0059f3665c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; class &gt; typename AtomicWrapper = std::atomic&gt;<br />
struct Pix::Pulley::Futex&lt; AtomicWrapper &gt;</h3>

<p>The <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a> class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. </p>
<p>At a lower level, the futex is assosciated with a wait queue (managed by the kernel) to which threads are added in the case that the lock is contended (unlikely) case.</p>
<p>The futex API provided here allows a waitmask to be specified when a thread will try and take the lock (or wait). To wake the thread assosciated with the waitmask, the same waitmask must be provided. The waitmask is, however, optional, and one can instead wake all waiters on a lock. This can degrade performance though, as the threads then race to contend the lock. It is preferable to use a waitmask when waitingand wake a minimal number of threads on wach wake.</p>
<p>A <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a> is particularly useful is when we require the combined functionality of a mutex and a condition variable (on the atomic unsigned integer condition), at the same time, as it is both more time and space efficient.</p>
<p>This implementation of the <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a> is simply a wrapper around the syscall on unix, since we have the syscall available.</p>
<p>Example usage is (See <a class="el" href="classPix_1_1Pulley_1_1MPMCQueue.html" title="The MPMCQueue is a multi producer, multi consumer queue, which does not use aby locking, but rather uses atomic variables to allow concurrent pushing and popping of elements to and from the queue. ">MPMCQueue</a>):</p>
<div class="fragment"></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AtomicWrapper</td><td>The atomic type wrapping the uint32_t futex value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>change template &lt;template &lt;class&gt; typename ...&gt; to template &lt;template &lt;typename&gt; typename ...&gt; when all compilers support c++17. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a035f9bf595b6131cb3c6600fb9250350"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; typename AtomicWrapper = std::atomic&gt; </div>
<div class="memtemplate">
template&lt;typename ClockType , typename Duration  = ClockType::duration&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structPix_1_1Pulley_1_1Futex.html">Pix::Pulley::Futex</a>&lt; AtomicWrapper &gt;::<a class="el" href="structPix_1_1Pulley_1_1Futex.html#a035f9bf595b6131cb3c6600fb9250350">Timepoint</a> =  std::chrono::time_point&lt;ClockType, Duration&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an alias for a general timepoint. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ClockType</td><td>The type of the clock used for the timepoint. </td></tr>
    <tr><td class="paramname">Duration</td><td>The duration used by the clock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a423685a4f1392a60eaac6e4a11816423"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; typename AtomicWrapper = std::atomic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPix_1_1Pulley_1_1Futex.html">Pix::Pulley::Futex</a>&lt; AtomicWrapper &gt;::<a class="el" href="structPix_1_1Pulley_1_1Futex.html">Futex</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initValue</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit constructor &ndash; initializes the <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a>, usually using the default value provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initValue</td><td>The initial value of the <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a281bee84e0903cebd6f1a44c955b34eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; typename AtomicWrapper = std::atomic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structPix_1_1Pulley_1_1Futex.html">Pix::Pulley::Futex</a>&lt; AtomicWrapper &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitMask</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the thread to sleep if the state of the futex (its value) is the value given by expected. </p>
<p>This returns true if a <a class="el" href="structPix_1_1Pulley_1_1Futex.html#aaa99ac4cbeb9b9a03d0a074181324d43" title="Wakes up threads waiting on a the futex. ">wake()</a> is consumed, otherwise it will return false (on a signal, if the load is not equal to the expected result, or on spurious wakeup).</p>
<p>This method assumes that the <a class="el" href="structPix_1_1Pulley_1_1Futex.html" title="The Futex class defines a futex object which is an atomic 32 bit (on all platforms, be that 32, 64 bit etc.) unsigned integer which essentially stores the state of a lock for shared data. ">Futex</a> will be used only between threads of the same process, and not between different processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>The expected return value for the wait. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitMask</td><td>The mask used by the kernel to select which threads to wake up on a wake. When waking, only threads waiting on the futex will be woken when the wakeMask mates the waitmask given here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ff5cef18317b82818fc1a1e42240561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; typename AtomicWrapper = std::atomic&gt; </div>
<div class="memtemplate">
template&lt;typename ClockType , typename Duration  = ClockType::duration&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FutexOpResult <a class="el" href="structPix_1_1Pulley_1_1Futex.html">Pix::Pulley::Futex</a>&lt; AtomicWrapper &gt;::waitImpl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a035f9bf595b6131cb3c6600fb9250350">Timepoint</a>&lt; ClockType, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitMask</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the implementation of the wait functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>The expected value of the futex's current state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The max amount of time a wiating thread is allowed to block for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitMask</td><td>The mask used to "identify" the waiting thread. If a mask is used, then the same mask needs to be used when waking the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ClockType</td><td>The type of the clock being used for the timepoint. </td></tr>
    <tr><td class="paramname">Duration</td><td>The duration for the timepoint (defaults to the ClockType's durations). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78c86e2a6b016d168f8cba47cfc424ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; typename AtomicWrapper = std::atomic&gt; </div>
<div class="memtemplate">
template&lt;typename ClockType , typename Duration  = ClockType::duration&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FutexOpResult <a class="el" href="structPix_1_1Pulley_1_1Futex.html">Pix::Pulley::Futex</a>&lt; AtomicWrapper &gt;::waitUntil </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPix_1_1Pulley_1_1Futex.html#a035f9bf595b6131cb3c6600fb9250350">Timepoint</a>&lt; ClockType, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitMask</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="structPix_1_1Pulley_1_1Futex.html#a281bee84e0903cebd6f1a44c955b34eb" title="Puts the thread to sleep if the state of the futex (its value) is the value given by expected...">wait()</a>, but the additional maxTime parameter defines the maximum ammount of time a thread is allowed to block for (which is the absolute time (time_since_epoch). </p>
<p>This retuns a FutexOpResult. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>The expected return value for the wait. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The max absolute time a thread can block for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitMask</td><td>The mask used by the kernel to select which threads to wake up on a wake. When waking, only threads waiting on the futex will be woken when the wakeMask mates the waitmask given here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ClockType</td><td>The type of the clock being used for the timepoint. </td></tr>
    <tr><td class="paramname">Duration</td><td>The duration for the timepoint (defaults to the ClockType's durations). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa99ac4cbeb9b9a03d0a074181324d43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; typename AtomicWrapper = std::atomic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structPix_1_1Pulley_1_1Futex.html">Pix::Pulley::Futex</a>&lt; AtomicWrapper &gt;::wake </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em> = <code>std::numeric_limits&lt;&#160;uint32_t&#160;&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeMask</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakes up threads waiting on a the futex. </p>
<p>This will wake as many of the threads as specified, and by default wakes all waiting threads. The number of awoken threads is returned, or -1 if there was an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of threads which can be woken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeMask</td><td>The mask to use to determine if a thread should be woken. If the thread to wake was told to wait with a waitMask which matches wakeMask, then the thread is allowed to wake, otherwise it is not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/Users/robclucas/Pixel/Software/Documentation/scripts/Pulley/Include/Pixel/Pulley/Concurrent/<a class="el" href="Futex_8hpp_source.html">Futex.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- This file defines the footer to use when generating documentation      -->
<!-- for Pixel with Doxygen.                                                -->
<footer class="page-footer">
  <!--div class="container"-->
    <div class="row">
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
          <h5 class="blue-text text-darken-4">Footer Content</h5>
          <p class="blue-text text-darken-4">Organize footer content.</p>
        </div>
        <div class="right">
          <h5 class="blue-text text-darken-4">Links</h5>
        </div>
      </div>
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
    </div>
  <div class="footer-copyright">
    <div class="row">
      <div class="col s0 m2 l3">
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
          Â© 2016 Pixel Technologies, Ltd
        </div>
        <div class="right">
          <a class="grey-text text-lighten-4" href="#!">More Links</a>
        </div>
      </div>
      <div class="col s0 m2 l3">
      </div>
    </div>
  </div>
  <!--/div-->
</footer>
