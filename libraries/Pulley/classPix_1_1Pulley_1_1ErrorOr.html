<!-- This file defines the header to use when generating documentation for  -->
<!-- Pixel with Doxygen.                                                    -->
<html>
  <head>
    <!-- Import Google Icon Font -->
    <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Let the browser know that the website is optimized for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Pulley : Pix::Pulley::ErrorOr&lt; Type &gt; Class Template Reference</title>
    <title>Pix::Pulley::ErrorOr&lt; Type &gt; Class Template Reference</title>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/js/materialize.min.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="$sytlesheet" rel="stylesheet" type="text/css"/>
    <link href="pixel.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="DoxyFormat.js"></script>
  </head>
  <body class="site">
    <nav>
      <div class="nav-wrapper z-depth-1">
        <!-- All libraries are in the libraries/libname/ dir, and the main  -->
        <!-- index.html is at ../../                                        -->
        <a href="../../index.html" class="brand-logo center">
          <img border="0" src="../../images/PixelTechnologiesLogoLight.png" class="logo">
        </a>
        <ul class="left hide-on-med-and-down">
          <li><a href="#" data-activates="slide-out" class="button-collapse"><i class="material-icons">menu</i></a></li>
          <li><a href="../../GettingStarted.html">GettingStarted</a></li>
          <li><a href="../../Guides.html">Guides</a></li>
          <li><a href="../../Libraries.html">Libraries</a></li>
        </ul>
        <form>
          <div class="input-field right">
            <input id="search" type="search" placeholder="Search" required>
            <label for="search"><i class="material-icons">search</i></label>
            <i class="material-icons">close</i>
          </div>
        </form>
      </div>
    </nav>
    <!--div class="row">
      <div class="col s3 m3 l3">
      </div>
      <div class="col s6 m6 l6">
        <div class="card teal accent-4">
          <div class="card-action blue-text darken-4">
            <a href="index.html">Meta</a>
            <a href="files.html">Files</a>
          </div>
        </div>
      </div>
    </div-->
    <div id="top">
      <div id="content" class="site-content">
        <div class="row">
          <div class="col s0 m2 l3"> 
          </div>
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Pix</b></li><li class="navelem"><b>Pulley</b></li><li class="navelem"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPix_1_1Pulley_1_1ErrorOr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pix::Pulley::ErrorOr&lt; Type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> struct defines a class which is a union of a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> and the template type Type.  
 <a href="classPix_1_1Pulley_1_1ErrorOr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ErrorOr_8hpp_source.html">ErrorOr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae6f2fb2c49018a9d996a563e280026b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ae6f2fb2c49018a9d996a563e280026b6">StorageType</a> = std::conditional_t&lt; <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad7dc0642b6180d02a7e08517374e6a77">isRef</a>, <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a8347764ec8d50022806ffe4f8822e481">RefWrap</a>, Type &gt;</td></tr>
<tr class="memdesc:ae6f2fb2c49018a9d996a563e280026b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of storage for the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>.  <a href="#ae6f2fb2c49018a9d996a563e280026b6">More...</a><br /></td></tr>
<tr class="separator:ae6f2fb2c49018a9d996a563e280026b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c7a02297ee5af3301da99d3d3bb74ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a2c7a02297ee5af3301da99d3d3bb74ec">ErrorOr</a> (<a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> &amp;&amp;error)</td></tr>
<tr class="memdesc:a2c7a02297ee5af3301da99d3d3bb74ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor &ndash; creates the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> type from a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> type.  <a href="#a2c7a02297ee5af3301da99d3d3bb74ec">More...</a><br /></td></tr>
<tr class="separator:a2c7a02297ee5af3301da99d3d3bb74ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67b284e0fd9a024b215516114fab302"><td class="memTemplParams" colspan="2">template&lt;typename OtherType &gt; </td></tr>
<tr class="memitem:aa67b284e0fd9a024b215516114fab302"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa67b284e0fd9a024b215516114fab302">ErrorOr</a> (OtherType &amp;&amp;other, std::enable_if_t&lt; std::is_convertible&lt; OtherType, Type &gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:aa67b284e0fd9a024b215516114fab302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor &ndash; creates the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from some other type to the type being wrapped in this <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>, if it can be converted.  <a href="#aa67b284e0fd9a024b215516114fab302">More...</a><br /></td></tr>
<tr class="separator:aa67b284e0fd9a024b215516114fab302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace51577758b0f2ebeff4c266d5ea5717"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ace51577758b0f2ebeff4c266d5ea5717">ErrorOr</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ace51577758b0f2ebeff4c266d5ea5717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor &ndash; moves another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> into this one.  <a href="#ace51577758b0f2ebeff4c266d5ea5717">More...</a><br /></td></tr>
<tr class="separator:ace51577758b0f2ebeff4c266d5ea5717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b861fd2cd8ffc92040645e93321a97f"><td class="memTemplParams" colspan="2">template&lt;typename OtherType &gt; </td></tr>
<tr class="memitem:a2b861fd2cd8ffc92040645e93321a97f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a2b861fd2cd8ffc92040645e93321a97f">ErrorOr</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;other, std::enable_if_t&lt; std::is_convertible&lt; OtherType, Type &gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:a2b861fd2cd8ffc92040645e93321a97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor &ndash; creates the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another type being wrapped in an <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>, if the types are convertible.  <a href="#a2b861fd2cd8ffc92040645e93321a97f">More...</a><br /></td></tr>
<tr class="separator:a2b861fd2cd8ffc92040645e93321a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49fbf64d77475e8e6b1ee2a15d60df8"><td class="memTemplParams" colspan="2">template&lt;typename OtherType &gt; </td></tr>
<tr class="memitem:ae49fbf64d77475e8e6b1ee2a15d60df8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ae49fbf64d77475e8e6b1ee2a15d60df8">ErrorOr</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;other, std::enable_if_t&lt;!std::is_convertible&lt; OtherType, Type &gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:ae49fbf64d77475e8e6b1ee2a15d60df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor &ndash; creates an <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> wrapping a different type, when the types can't be converted.  <a href="#ae49fbf64d77475e8e6b1ee2a15d60df8">More...</a><br /></td></tr>
<tr class="separator:ae49fbf64d77475e8e6b1ee2a15d60df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e33dfb3c2e3ac783d24aa7660db0d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a0e33dfb3c2e3ac783d24aa7660db0d83">operator=</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a0e33dfb3c2e3ac783d24aa7660db0d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator &ndash; reates an <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>.  <a href="#a0e33dfb3c2e3ac783d24aa7660db0d83">More...</a><br /></td></tr>
<tr class="separator:a0e33dfb3c2e3ac783d24aa7660db0d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fb05895acece807da8c21a90cb7573"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11fb05895acece807da8c21a90cb7573"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a11fb05895acece807da8c21a90cb7573">~ErrorOr</a> ()</td></tr>
<tr class="memdesc:a11fb05895acece807da8c21a90cb7573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor &ndash; cleans up the memory for the Type. <br /></td></tr>
<tr class="separator:a11fb05895acece807da8c21a90cb7573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15fe3d05dabd50f065a19916cde94a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ae15fe3d05dabd50f065a19916cde94a3">operator bool</a> () const </td></tr>
<tr class="memdesc:ae15fe3d05dabd50f065a19916cde94a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converstion to bool operator.  <a href="#ae15fe3d05dabd50f065a19916cde94a3">More...</a><br /></td></tr>
<tr class="separator:ae15fe3d05dabd50f065a19916cde94a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a799490716b32c96123fcee2be5cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a93a799490716b32c96123fcee2be5cce">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:a93a799490716b32c96123fcee2be5cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the pointer access operator to provide a pointer to the (non-const) Type being wrapped.  <a href="#a93a799490716b32c96123fcee2be5cce">More...</a><br /></td></tr>
<tr class="separator:a93a799490716b32c96123fcee2be5cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3517407fd7a05379754383e00809b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a4a3517407fd7a05379754383e00809b1">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a4a3517407fd7a05379754383e00809b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the pointer access opertor to provide a pointer to the (cosnt) Type being wrapped.  <a href="#a4a3517407fd7a05379754383e00809b1">More...</a><br /></td></tr>
<tr class="separator:a4a3517407fd7a05379754383e00809b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90118881066870fd68c0047a4ee8db5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a9425eb11c70a8deb71d9024ba27ae7ba">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a90118881066870fd68c0047a4ee8db5b">operator*</a> ()</td></tr>
<tr class="memdesc:a90118881066870fd68c0047a4ee8db5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the unary* operator to provide a (non-const) reference to the Type being wrapped.  <a href="#a90118881066870fd68c0047a4ee8db5b">More...</a><br /></td></tr>
<tr class="separator:a90118881066870fd68c0047a4ee8db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed99a52aebce41fadb4c29a3c9433d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aca2929c96397157491f2ebeeac59fd68">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aed99a52aebce41fadb4c29a3c9433d08">operator*</a> () const </td></tr>
<tr class="memdesc:aed99a52aebce41fadb4c29a3c9433d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the unary* opertor to provide a (const) reference to the Type being wrapped.  <a href="#aed99a52aebce41fadb4c29a3c9433d08">More...</a><br /></td></tr>
<tr class="separator:aed99a52aebce41fadb4c29a3c9433d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1456980d646e218e39955e6a0f657c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1456980d646e218e39955e6a0f657c5"></a>
<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a9425eb11c70a8deb71d9024ba27ae7ba">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ae1456980d646e218e39955e6a0f657c5">get</a> ()</td></tr>
<tr class="memdesc:ae1456980d646e218e39955e6a0f657c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (non-const) reference to the Type being wrapped. <br /></td></tr>
<tr class="separator:ae1456980d646e218e39955e6a0f657c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad897c1a89df85c5179e9b17482cf93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ad897c1a89df85c5179e9b17482cf93"></a>
<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aca2929c96397157491f2ebeeac59fd68">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a9ad897c1a89df85c5179e9b17482cf93">get</a> () const </td></tr>
<tr class="memdesc:a9ad897c1a89df85c5179e9b17482cf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (const) reference to the Type being wrapped. <br /></td></tr>
<tr class="separator:a9ad897c1a89df85c5179e9b17482cf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9140ab03fa1ae0079003e1000ff0607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ac9140ab03fa1ae0079003e1000ff0607">takeError</a> ()</td></tr>
<tr class="memdesc:ac9140ab03fa1ae0079003e1000ff0607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the error to be taken (moved) from the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>.  <a href="#ac9140ab03fa1ae0079003e1000ff0607">More...</a><br /></td></tr>
<tr class="separator:ac9140ab03fa1ae0079003e1000ff0607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceffaf2ffa9dfa6521b887d9246a10d"><td class="memTemplParams" colspan="2">template&lt;typename ErrorType &gt; </td></tr>
<tr class="memitem:a9ceffaf2ffa9dfa6521b887d9246a10d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a9ceffaf2ffa9dfa6521b887d9246a10d">errorIsA</a> () const </td></tr>
<tr class="memdesc:a9ceffaf2ffa9dfa6521b887d9246a10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the wrapped error is a specific type of error.  <a href="#a9ceffaf2ffa9dfa6521b887d9246a10d">More...</a><br /></td></tr>
<tr class="separator:a9ceffaf2ffa9dfa6521b887d9246a10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9425eb11c70a8deb71d9024ba27ae7ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9425eb11c70a8deb71d9024ba27ae7ba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a9425eb11c70a8deb71d9024ba27ae7ba">Reference</a> = std::remove_reference_t&lt; Type &gt; &amp;</td></tr>
<tr class="memdesc:a9425eb11c70a8deb71d9024ba27ae7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a reference to the Type. <br /></td></tr>
<tr class="separator:a9425eb11c70a8deb71d9024ba27ae7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2929c96397157491f2ebeeac59fd68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2929c96397157491f2ebeeac59fd68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aca2929c96397157491f2ebeeac59fd68">ConstReference</a> = const std::remove_reference_t&lt; Type &gt; &amp;</td></tr>
<tr class="memdesc:aca2929c96397157491f2ebeeac59fd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a const reference to the Type. <br /></td></tr>
<tr class="separator:aca2929c96397157491f2ebeeac59fd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa962d2b51c3c41e67ec223666feab351"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa962d2b51c3c41e67ec223666feab351"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a> = std::remove_reference_t&lt; Type &gt; *</td></tr>
<tr class="memdesc:aa962d2b51c3c41e67ec223666feab351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a pointer to the Type. <br /></td></tr>
<tr class="separator:aa962d2b51c3c41e67ec223666feab351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9866a06f54164cf88de91341bb620b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9866a06f54164cf88de91341bb620b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a> = const std::remove_reference_t&lt; Type &gt; *</td></tr>
<tr class="memdesc:ad9866a06f54164cf88de91341bb620b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a const pointer to the type. <br /></td></tr>
<tr class="separator:ad9866a06f54164cf88de91341bb620b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8347764ec8d50022806ffe4f8822e481"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8347764ec8d50022806ffe4f8822e481"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a8347764ec8d50022806ffe4f8822e481">RefWrap</a> = <a class="el" href="classPix_1_1Pulley_1_1ReferenceStorage.html">ReferenceStorage</a>&lt; std::remove_reference_t&lt; Type &gt;&gt;</td></tr>
<tr class="memdesc:a8347764ec8d50022806ffe4f8822e481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of the reference wrapped class when Type is a reference. <br /></td></tr>
<tr class="separator:a8347764ec8d50022806ffe4f8822e481"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad12d56c00af3a4496b419906e098120d"><td class="memTemplParams" colspan="2">template&lt;typename OtherType &gt; </td></tr>
<tr class="memitem:ad12d56c00af3a4496b419906e098120d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad12d56c00af3a4496b419906e098120d">moveConstruct</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ad12d56c00af3a4496b419906e098120d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> with a convertible type.  <a href="#ad12d56c00af3a4496b419906e098120d">More...</a><br /></td></tr>
<tr class="separator:ad12d56c00af3a4496b419906e098120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab520706aa478e6f421b476faf37fbaae"><td class="memTemplParams" colspan="2">template&lt;typename OtherType &gt; </td></tr>
<tr class="memitem:ab520706aa478e6f421b476faf37fbaae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ab520706aa478e6f421b476faf37fbaae">moveAssign</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ab520706aa478e6f421b476faf37fbaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> with a convertible type.  <a href="#ab520706aa478e6f421b476faf37fbaae">More...</a><br /></td></tr>
<tr class="separator:ab520706aa478e6f421b476faf37fbaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709f410f83efb717757baa2f54a0f34e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a709f410f83efb717757baa2f54a0f34e"></a>
<a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a709f410f83efb717757baa2f54a0f34e">getErrorStorage</a> ()</td></tr>
<tr class="memdesc:a709f410f83efb717757baa2f54a0f34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a>'s memory in the aligned char array. <br /></td></tr>
<tr class="separator:a709f410f83efb717757baa2f54a0f34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7436dbd183567d4da582571b69d58b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f7436dbd183567d4da582571b69d58b"></a>
const <a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getErrorStorage</b> () const </td></tr>
<tr class="separator:a1f7436dbd183567d4da582571b69d58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39f57807ba6e65875b1a49b27062ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae39f57807ba6e65875b1a49b27062ab9"></a>
<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ae39f57807ba6e65875b1a49b27062ab9">getStorage</a> () const </td></tr>
<tr class="memdesc:ae39f57807ba6e65875b1a49b27062ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Type's (const) memory. <br /></td></tr>
<tr class="separator:ae39f57807ba6e65875b1a49b27062ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac44d9161ddc7c25713bc09c258320e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ac44d9161ddc7c25713bc09c258320e"></a>
<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a9ac44d9161ddc7c25713bc09c258320e">getStorage</a> ()</td></tr>
<tr class="memdesc:a9ac44d9161ddc7c25713bc09c258320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Type's memory. <br /></td></tr>
<tr class="separator:a9ac44d9161ddc7c25713bc09c258320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73879c9e525b876917f216136e9d6bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa73879c9e525b876917f216136e9d6bc">toPointer</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a> val)</td></tr>
<tr class="memdesc:aa73879c9e525b876917f216136e9d6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to a (non-const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> to a pointer to a (non-const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>.  <a href="#aa73879c9e525b876917f216136e9d6bc">More...</a><br /></td></tr>
<tr class="separator:aa73879c9e525b876917f216136e9d6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867f6a795f0f2f1b0b0e4e0b1f774d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a867f6a795f0f2f1b0b0e4e0b1f774d0b">toPointer</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a> val) const </td></tr>
<tr class="memdesc:a867f6a795f0f2f1b0b0e4e0b1f774d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to a (const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> to a pointer to a (const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>.  <a href="#a867f6a795f0f2f1b0b0e4e0b1f774d0b">More...</a><br /></td></tr>
<tr class="separator:a867f6a795f0f2f1b0b0e4e0b1f774d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafc8e36050a3a74d9d51c00579604b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#abafc8e36050a3a74d9d51c00579604b6">toPointer</a> (<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a8347764ec8d50022806ffe4f8822e481">RefWrap</a> *val)</td></tr>
<tr class="memdesc:abafc8e36050a3a74d9d51c00579604b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to a (non-const) wrapped reference, to a pointer to a (non-const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>.  <a href="#abafc8e36050a3a74d9d51c00579604b6">More...</a><br /></td></tr>
<tr class="separator:abafc8e36050a3a74d9d51c00579604b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9920816688397938e87243f6bdd0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a7e9920816688397938e87243f6bdd0d0">toPointer</a> (const <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a8347764ec8d50022806ffe4f8822e481">RefWrap</a> *val) const </td></tr>
<tr class="memdesc:a7e9920816688397938e87243f6bdd0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to a (const) wrapped reference, to a pointer to a (const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>.  <a href="#a7e9920816688397938e87243f6bdd0d0">More...</a><br /></td></tr>
<tr class="separator:a7e9920816688397938e87243f6bdd0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:af35af17d272284a98a3da31bd55e6373"><td class="memTemplParams" colspan="2">template&lt;typename Type1 &gt; </td></tr>
<tr class="memitem:af35af17d272284a98a3da31bd55e6373"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#af35af17d272284a98a3da31bd55e6373">isSameObject</a> (const Type1 &amp;a, const Type1 &amp;b)</td></tr>
<tr class="memdesc:af35af17d272284a98a3da31bd55e6373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if two objects (of the same type) are the same object (by checking if they have the same memory location).  <a href="#af35af17d272284a98a3da31bd55e6373">More...</a><br /></td></tr>
<tr class="separator:af35af17d272284a98a3da31bd55e6373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac035ce5bef6d287e022a294a203abcfa"><td class="memTemplParams" colspan="2">template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:ac035ce5bef6d287e022a294a203abcfa"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ac035ce5bef6d287e022a294a203abcfa">isSameObject</a> (const Type1 &amp;a, const Type2 &amp;b)</td></tr>
<tr class="memdesc:ac035ce5bef6d287e022a294a203abcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if two objects (of the different type) are the same object, Since they cannot be, this returns false.  <a href="#ac035ce5bef6d287e022a294a203abcfa">More...</a><br /></td></tr>
<tr class="separator:ac035ce5bef6d287e022a294a203abcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a48fdc5c935bb250c6c0f2ec5ebdf2e8a"><td class="memItemLeft" ><a class="anchor" id="a48fdc5c935bb250c6c0f2ec5ebdf2e8a"></a>
union {</td></tr>
<tr class="memitem:aab04aa84503e6c1cb92f29e6b02df1c6"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="structPix_1_1Pulley_1_1AlignedCharArrayUnion.html">AlignedCharArrayUnion</a><br class="typebreak" />
&lt; <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ae6f2fb2c49018a9d996a563e280026b6">StorageType</a> &gt;&#160;&#160;&#160;<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ab40849b6bb90518c7ca5425444ba802f">TypeStorage</a></td></tr>
<tr class="memdesc:aab04aa84503e6c1cb92f29e6b02df1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for when ErrorOr&lt;T&gt; is the Type. <br /></td></tr>
<tr class="separator:aab04aa84503e6c1cb92f29e6b02df1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db4f1c01ec4b0e764acff0a2df9a4cf"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="structPix_1_1Pulley_1_1AlignedCharArrayUnion.html">AlignedCharArrayUnion</a>&lt; <a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> &gt;&#160;&#160;&#160;<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#adf8a8d25ccd2a1f18c8b4ac85d2e2a6e">ErrorStorage</a></td></tr>
<tr class="memdesc:a0db4f1c01ec4b0e764acff0a2df9a4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for when ErrorOr&lt;T&gt; is a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a>. <br /></td></tr>
<tr class="separator:a0db4f1c01ec4b0e764acff0a2df9a4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fdc5c935bb250c6c0f2ec5ebdf2e8a"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a48fdc5c935bb250c6c0f2ec5ebdf2e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7931d9b847c9cdcb35fa0156925be2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b7931d9b847c9cdcb35fa0156925be2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a0b7931d9b847c9cdcb35fa0156925be2">HasError</a>: 1</td></tr>
<tr class="memdesc:a0b7931d9b847c9cdcb35fa0156925be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">States whether ErrorOr&lt;T&gt; is a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> or is the Type. <br /></td></tr>
<tr class="separator:a0b7931d9b847c9cdcb35fa0156925be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ad7dc0642b6180d02a7e08517374e6a77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7dc0642b6180d02a7e08517374e6a77"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad7dc0642b6180d02a7e08517374e6a77">isRef</a> = std::is_reference&lt;Type&gt;::value</td></tr>
<tr class="memdesc:ad7dc0642b6180d02a7e08517374e6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type is a reference type. <br /></td></tr>
<tr class="separator:ad7dc0642b6180d02a7e08517374e6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7efd4fdaf2b3305e13c1358dff404193"><td class="memTemplParams" colspan="2">template&lt;typename OtherType &gt; </td></tr>
<tr class="memitem:a7efd4fdaf2b3305e13c1358dff404193"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a7efd4fdaf2b3305e13c1358dff404193">ErrorOr</a></td></tr>
<tr class="memdesc:a7efd4fdaf2b3305e13c1358dff404193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> objects with different template parameters are allowed to access the internals of other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> objects.  <a href="#a7efd4fdaf2b3305e13c1358dff404193">More...</a><br /></td></tr>
<tr class="separator:a7efd4fdaf2b3305e13c1358dff404193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type&gt;<br />
class Pix::Pulley::ErrorOr&lt; Type &gt;</h3>

<p>The <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> struct defines a class which is a union of a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> and the template type Type. </p>
<p>It is a smart pointer like class, which represents either the Type in the success case, or a relevant <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> in the failure case. This is similar to having a nullptr in the failure case, but instead we have rich error information. The following is example usage:</p>
<div class="fragment"><div class="line"><span class="comment">// Function which returns the Buffer object:</span></div>
<div class="line">ErrorOr&lt;Buffer&gt; makeBuffer();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Current:</span></div>
<div class="line"><span class="keyword">auto</span> buffer = makeBuffer();</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> err = buffer.getError()) {</div>
<div class="line">  <span class="keywordflow">return</span> err;</div>
<div class="line">};</div>
<div class="line">buffer.write(<span class="stringliteral">&quot;Example&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// A potential improvement, to eliminate if check in release code, would</span></div>
<div class="line"><span class="comment">// be something like the folllowing:</span></div>
<div class="line"><span class="keyword">auto</span> buffer = makeBuffer();</div>
<div class="line"></div>
<div class="line"><span class="comment">// We can completely remove this call at compile </span></div>
<div class="line"><span class="comment">// time, elimnating all checking overhead</span></div>
<div class="line">ifError(buffer, [] {</div>
<div class="line">  <span class="keywordflow">return</span> buffer.getError();</div>
<div class="line">});</div>
<div class="line">buffer.write(<span class="stringliteral">&quot;Example&quot;</span>);</div>
</div><!-- fragment --><p>The <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> type has the same access as a smart pointer, with the unary * and -&gt; operators. If the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> is an the behaviour in undefined. Also, in the case that Type is a reference, <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> acts as if Type is <b>not</b> a reference i.e, the operators * and -&gt; should be used as if the wrapped type were not a reference.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type which is wrapped to include and error. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ae6f2fb2c49018a9d996a563e280026b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ae6f2fb2c49018a9d996a563e280026b6">StorageType</a> =  std::conditional_t&lt;<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad7dc0642b6180d02a7e08517374e6a77">isRef</a>, <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a8347764ec8d50022806ffe4f8822e481">RefWrap</a>, Type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the type of storage for the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </p>
<p>We do this so that the same interface can be used for a Type and reference to a Type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2c7a02297ee5af3301da99d3d3bb74ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor &ndash; creates the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> type from a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> type. </p>
<p>Sets that the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> class is wrapping and error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The error to set for the wrap type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa67b284e0fd9a024b215516114fab302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename OtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> </td>
          <td>(</td>
          <td class="paramtype">OtherType &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_convertible&lt; OtherType, Type &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor &ndash; creates the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from some other type to the type being wrapped in this <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>, if it can be converted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other type to try and wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>The type of the object to wrap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace51577758b0f2ebeff4c266d5ea5717"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; Type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor &ndash; moves another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> type to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b861fd2cd8ffc92040645e93321a97f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename OtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_convertible&lt; OtherType, Type &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor &ndash; creates the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another type being wrapped in an <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>, if the types are convertible. </p>
<p>wrapped in this <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>, if it can be converted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> object to create from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>The type of the object wrapped in an <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae49fbf64d77475e8e6b1ee2a15d60df8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename OtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::<a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_convertible&lt; OtherType, Type &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor &ndash; creates an <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> wrapping a different type, when the types can't be converted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> wrapping a different type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>The other type being wrapped in another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: Handle this case! </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9ceffaf2ffa9dfa6521b887d9246a10d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename ErrorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::errorIsA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the wrapped error is a specific type of error. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ErrorType</td><td>The type of the error to check for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af35af17d272284a98a3da31bd55e6373"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename Type1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::isSameObject </td>
          <td>(</td>
          <td class="paramtype">const Type1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares if two objects (of the same type) are the same object (by checking if they have the same memory location). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first object in the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second object in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type1</td><td>The type of the objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac035ce5bef6d287e022a294a203abcfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename Type1 , typename Type2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::isSameObject </td>
          <td>(</td>
          <td class="paramtype">const Type1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares if two objects (of the different type) are the same object, Since they cannot be, this returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first object in the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second object in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type1</td><td>The type of the first object. </td></tr>
    <tr><td class="paramname">Type2</td><td>The type of the second object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab520706aa478e6f421b476faf37fbaae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename OtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::moveAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assigns the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> with a convertible type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> to use for creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>The type being wrapped in another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad12d56c00af3a4496b419906e098120d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename OtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::moveConstruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; OtherType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> with a convertible type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> to use for creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>The type being wrapped in another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae15fe3d05dabd50f065a19916cde94a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converstion to bool operator. </p>
<p>This returns true if the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> is wrapping the Type and <b>not</b> in the error state. </p>

</div>
</div>
<a class="anchor" id="a90118881066870fd68c0047a4ee8db5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a9425eb11c70a8deb71d9024ba27ae7ba">Reference</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the unary* operator to provide a (non-const) reference to the Type being wrapped. </p>

</div>
</div>
<a class="anchor" id="aed99a52aebce41fadb4c29a3c9433d08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aca2929c96397157491f2ebeeac59fd68">ConstReference</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the unary* opertor to provide a (const) reference to the Type being wrapped. </p>

</div>
</div>
<a class="anchor" id="a93a799490716b32c96123fcee2be5cce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the pointer access operator to provide a pointer to the (non-const) Type being wrapped. </p>

</div>
</div>
<a class="anchor" id="a4a3517407fd7a05379754383e00809b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the pointer access opertor to provide a pointer to the (cosnt) Type being wrapped. </p>

</div>
</div>
<a class="anchor" id="a0e33dfb3c2e3ac783d24aa7660db0d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&amp; <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a>&lt; Type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator &ndash; reates an <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> from another <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> to create from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9140ab03fa1ae0079003e1000ff0607"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1TypedError.html">TypedError</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::takeError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the error to be taken (moved) from the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </p>
<p>This returns the <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> being wrapped. If a <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> is not being wrapped (i,e the <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> type is wrapping an actual value) then a new <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a> is created to indicate a success case <a class="el" href="classPix_1_1Pulley_1_1TypedError.html" title="The TypedError class is a simple, fast error class which can include error context, and ensures that any errors are checked before destruction. ">TypedError</a>. </p>

</div>
</div>
<a class="anchor" id="aa73879c9e525b876917f216136e9d6bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::toPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to a (non-const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> to a pointer to a (non-const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to convert to a pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a867f6a795f0f2f1b0b0e4e0b1f774d0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::toPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to a (const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> to a pointer to a (const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to convert to a pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abafc8e36050a3a74d9d51c00579604b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#aa962d2b51c3c41e67ec223666feab351">Pointer</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::toPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a8347764ec8d50022806ffe4f8822e481">RefWrap</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to a (non-const) wrapped reference, to a pointer to a (non-const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The wrapped reference type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e9920816688397938e87243f6bdd0d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#ad9866a06f54164cf88de91341bb620b0">ConstPointer</a> <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">Pix::Pulley::ErrorOr</a>&lt; Type &gt;::toPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html#a8347764ec8d50022806ffe4f8822e481">RefWrap</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to a (const) wrapped reference, to a pointer to a (const) <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The wrapped reference type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a7efd4fdaf2b3305e13c1358dff404193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<div class="memtemplate">
template&lt;typename OtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html">ErrorOr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> objects with different template parameters are allowed to access the internals of other <a class="el" href="classPix_1_1Pulley_1_1ErrorOr.html" title="The ErrorOr struct defines a class which is a union of a TypedError and the template type Type...">ErrorOr</a> objects. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/robclucas/Pixel/Software/Documentation/scripts/Pulley/Include/Pixel/Pulley/Error/<a class="el" href="ErrorOr_8hpp_source.html">ErrorOr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- This file defines the footer to use when generating documentation      -->
<!-- for Pixel with Doxygen.                                                -->
<footer class="page-footer">
  <!--div class="container"-->
    <div class="row">
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
          <h5 class="blue-text text-darken-4">Footer Content</h5>
          <p class="blue-text text-darken-4">Organize footer content.</p>
        </div>
        <div class="right">
          <h5 class="blue-text text-darken-4">Links</h5>
        </div>
      </div>
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
    </div>
  <div class="footer-copyright">
    <div class="row">
      <div class="col s0 m2 l3">
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
           2016 Pixel Technologies, Ltd
        </div>
        <div class="right">
          <a class="grey-text text-lighten-4" href="#!">More Links</a>
        </div>
      </div>
      <div class="col s0 m2 l3">
      </div>
    </div>
  </div>
  <!--/div-->
</footer>
