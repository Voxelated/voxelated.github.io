<!-- This file defines the header to use when generating documentation with -->
<!-- DoxyFormat.                                                            -->
<html>
  <head>
    <!-- Import Google Icon Font -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Let the browser know that the website is optimized for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Conky : Voxx::Conky::ThreadPool&lt; TasksPerQueue, Policy, TaskAlignment &gt;</title>
    <title>Voxx::Conky::ThreadPool&lt; TasksPerQueue, Policy, TaskAlignment &gt;</title>
    <link rel="shortcut icon" href="VoxelLogoSmall.png">
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/js/materialize.min.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <!-- NOTE: We first load the doxygen stylesheet, and then we try and load the stylesheet of the site
               to which this documentation will belong, and then we load the custom stylesheet
      -->
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="/css/main.css" rel="stylesheet" type="text/css"/>
    <link href="sytlesheet.css" rel="stylesheet" type="text/css"/>
    <!-- Load the javascript which converts the doxygen output to material style -->
    <script type="text/javascript" src="DoxyFormat.js"></script>
  </head>
  <div class="navbar-fixed z-depth-1">
  <nav>
    <!--div class="nav-wrapper z-depth-1"-->
      <!-- All libraries are in the libraries/ dir, and the main index.html   -->
      <!-- is at ../                                                          -->
      <ul class="left">
        <li><a href="#" data-activates="slide-out" class="button-collapse"><i class="material-icons material-icons-logo">menu</i></a></li>
        <li><a href="https://voxelated.github.io/index.html" class="voxel-header-logo"><img src="VoxelLogoSmall.png" class="logo">oxel </a></li>
        <li><a href="https://voxelated.github.io/GettingStarted.html" class="voxel-navbar-element hide-on-med-and-down">GettingStarted</a></li>
        <li><a href="https://voxelated.github.io/Guides.html" class="voxel-navbar-element hide-on-med-and-down" >Guides</a></li>
        <li><a href="https://voxelated.github.io/Libraries.html" class="voxel-navbar-element hide-on-med-and-down">Libraries</a></li>
        <li><a href="https://github.com/Voxelated/Conky" class="voxel-navbar-element hide-on-med-and-down">Repository</a></li>
      </ul>
      <form>
        <div class="input-field hide-on-med-and-down right">
          <input id="search" type="search" placeholder="Search" required>
          <label for="search"><i class="material-icons">search</i></label>
          <i class="material-icons">close</i>
        </div>
      </form>
    <!--/div-->
  </nav>
  </div>
  <div class="col s2 m2 l3">
    <ul id="slide-out" class="side-nav z-depth-2 left-aligned">
      <li><a href="https://voxelated.github.io/GettingStarted.html">GettingStarted</a></li>
      <li><a href="https://voxelated.github.io/Guides.html">Guides</a></li>
      <li><a href="https://voxelated.github.io/Libraries.html" class="voxel-navbar-element">Libraries</a></li>
      <li><a href="https://github.com/Voxelated/Conky" class="voxel-navbar-element hide-on-med-and-down">Repository</a></li>
    </ul>
  </div>
  <body class="site">
    <div id="top">
      <div id="content" class="site-content">
        <div class="row">
          <div class="col s0 m2 l3"> 
          </div>
    <!-- The rest is filled by doxygen ... -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Voxx</b></li><li class="navelem"><b>Conky</b></li><li class="navelem"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classVoxx_1_1Conky_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Voxx::Conky::ThreadPool&lt; TasksPerQueue, Policy, TaskAlignment &gt;</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html" title="The ThreadPool class creates a thread pool with one controlling thread (which may be extended to be a...">ThreadPool</a> class creates a thread pool with one controlling thread (which may be extended to be an interruptible worker thread) and (N - 1) worker threads, wher N is the total number of threads in the pool.  
 <a href="classVoxx_1_1Conky_1_1ThreadPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ThreadPool_8hpp_source.html">ThreadPool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1StealOverloader.html">StealOverloader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1StealOverloader.html" title="The StealOverloader struct is used to overload the stealing implementation based on the provided poli...">StealOverloader</a> struct is used to overload the stealing implementation based on the provided policy.  <a href="structVoxx_1_1Conky_1_1ThreadPool_1_1StealOverloader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1TaskQueue.html">TaskQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1TaskQueue.html" title="The TaskQueue defines a correctly aligned queue of tasks for a thread. ">TaskQueue</a> defines a correctly aligned queue of tasks for a thread.  <a href="structVoxx_1_1Conky_1_1ThreadPool_1_1TaskQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a960384793661c3e689ec66eba93fac8b"><td class="memItemLeft" align="right" valign="top"><a id="a960384793661c3e689ec66eba93fac8b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a960384793661c3e689ec66eba93fac8b">TaskType</a> = <a class="el" href="structVoxx_1_1Conky_1_1Task.html">Task</a>&lt; TaskAlignment &gt;</td></tr>
<tr class="memdesc:a960384793661c3e689ec66eba93fac8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of the tasks. <br /></td></tr>
<tr class="separator:a960384793661c3e689ec66eba93fac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc979c231259442c770d1a4eef8709d"><td class="memItemLeft" align="right" valign="top"><a id="acdc979c231259442c770d1a4eef8709d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#acdc979c231259442c770d1a4eef8709d">FlagContainer</a> = std::vector&lt; uint8_t &gt;</td></tr>
<tr class="memdesc:acdc979c231259442c770d1a4eef8709d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of container for the flags to control the worker threads. <br /></td></tr>
<tr class="separator:acdc979c231259442c770d1a4eef8709d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2725de2ad08dfa205e1055394c17a5"><td class="memItemLeft" align="right" valign="top"><a id="acf2725de2ad08dfa205e1055394c17a5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#acf2725de2ad08dfa205e1055394c17a5">QueueContainer</a> = std::vector&lt; <a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1TaskQueue.html">TaskQueue</a> &gt;</td></tr>
<tr class="memdesc:acf2725de2ad08dfa205e1055394c17a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of container for the queues. <br /></td></tr>
<tr class="separator:acf2725de2ad08dfa205e1055394c17a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e403696928c7b974efb78c4e628b88"><td class="memItemLeft" align="right" valign="top"><a id="a58e403696928c7b974efb78c4e628b88"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a58e403696928c7b974efb78c4e628b88">ThreadContainer</a> = std::vector&lt; std::thread &gt;</td></tr>
<tr class="memdesc:a58e403696928c7b974efb78c4e628b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of thread container. <br /></td></tr>
<tr class="separator:a58e403696928c7b974efb78c4e628b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a727edbad33f2f019ef1ea0d6931ec262"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a727edbad33f2f019ef1ea0d6931ec262">ThreadPool</a> (std::size_t numThreads)</td></tr>
<tr class="memdesc:a727edbad33f2f019ef1ea0d6931ec262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor &ndash; creates <code>numThreads</code> - 1 threads and starts processing tasks on them.  <a href="#a727edbad33f2f019ef1ea0d6931ec262">More...</a><br /></td></tr>
<tr class="separator:a727edbad33f2f019ef1ea0d6931ec262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a84af47e07fb0c71fa57cec712182e"><td class="memItemLeft" align="right" valign="top"><a id="a81a84af47e07fb0c71fa57cec712182e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a81a84af47e07fb0c71fa57cec712182e">~ThreadPool</a> () noexcept</td></tr>
<tr class="memdesc:a81a84af47e07fb0c71fa57cec712182e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor &ndash; joins the threads. <br /></td></tr>
<tr class="separator:a81a84af47e07fb0c71fa57cec712182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc541275693b3cd0b99759ef2802a511"><td class="memTemplParams" colspan="2">template&lt;typename TaskCallable , typename... TaskArgs&gt; </td></tr>
<tr class="memitem:abc541275693b3cd0b99759ef2802a511"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#abc541275693b3cd0b99759ef2802a511">tryPush</a> (TaskCallable &amp;&amp;callable, TaskArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:abc541275693b3cd0b99759ef2802a511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to push an object onto the worker queue for the current thread.  <a href="#abc541275693b3cd0b99759ef2802a511">More...</a><br /></td></tr>
<tr class="separator:abc541275693b3cd0b99759ef2802a511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb0c21fdfe3457231abe6b9c01fcd3d"><td class="memItemLeft" align="right" valign="top"><a id="a6cb0c21fdfe3457231abe6b9c01fcd3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a6cb0c21fdfe3457231abe6b9c01fcd3d">stopThreads</a> () noexcept</td></tr>
<tr class="memdesc:a6cb0c21fdfe3457231abe6b9c01fcd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the threads from running. <br /></td></tr>
<tr class="separator:a6cb0c21fdfe3457231abe6b9c01fcd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c219ac4227a19f806110246c349f561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a2c219ac4227a19f806110246c349f561">startThreads</a> () noexcept</td></tr>
<tr class="memdesc:a2c219ac4227a19f806110246c349f561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the threads running.  <a href="#a2c219ac4227a19f806110246c349f561">More...</a><br /></td></tr>
<tr class="separator:a2c219ac4227a19f806110246c349f561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0159256530cb47af45cf42a848109e46"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a0159256530cb47af45cf42a848109e46">runningThreads</a> () const noexcept</td></tr>
<tr class="memdesc:a0159256530cb47af45cf42a848109e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads which are running.  <a href="#a0159256530cb47af45cf42a848109e46">More...</a><br /></td></tr>
<tr class="separator:a0159256530cb47af45cf42a848109e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f5327241efc9ba7e69194b0b110a52"><td class="memItemLeft" align="right" valign="top"><a id="ae2f5327241efc9ba7e69194b0b110a52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ae2f5327241efc9ba7e69194b0b110a52">waitTillIdle</a> () const noexcept</td></tr>
<tr class="memdesc:ae2f5327241efc9ba7e69194b0b110a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the thread pool has no work. <br /></td></tr>
<tr class="separator:ae2f5327241efc9ba7e69194b0b110a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e711954f70e25be86d01b32562d12e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a6e711954f70e25be86d01b32562d12e3">isEmpty</a> () const noexcept</td></tr>
<tr class="memdesc:a6e711954f70e25be86d01b32562d12e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the thread pool has no more work, otherwise it returns false.  <a href="#a6e711954f70e25be86d01b32562d12e3">More...</a><br /></td></tr>
<tr class="separator:a6e711954f70e25be86d01b32562d12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9c2e06efc92952cb5cc4acee06ed925b"><td class="memItemLeft" align="right" valign="top"><a id="a9c2e06efc92952cb5cc4acee06ed925b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a9c2e06efc92952cb5cc4acee06ed925b">StealSelector</a> = <a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1StealOverloader.html">StealOverloader</a>&lt; Policy &gt;</td></tr>
<tr class="memdesc:a9c2e06efc92952cb5cc4acee06ed925b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of the stealing method selector. <br /></td></tr>
<tr class="separator:a9c2e06efc92952cb5cc4acee06ed925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310b6404eb1992a2d2bd6ef3b9d0479e"><td class="memItemLeft" align="right" valign="top"><a id="a310b6404eb1992a2d2bd6ef3b9d0479e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a310b6404eb1992a2d2bd6ef3b9d0479e">RandomSteal</a> = <a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1StealOverloader.html">StealOverloader</a>&lt; StealPolicy::Random &gt;</td></tr>
<tr class="memdesc:a310b6404eb1992a2d2bd6ef3b9d0479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of overloader for random stealing. <br /></td></tr>
<tr class="separator:a310b6404eb1992a2d2bd6ef3b9d0479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97f64095bb82d52b499b4eb7623f2cf"><td class="memItemLeft" align="right" valign="top"><a id="ac97f64095bb82d52b499b4eb7623f2cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ac97f64095bb82d52b499b4eb7623f2cf">NNeighbourSteal</a> = <a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1StealOverloader.html">StealOverloader</a>&lt; StealPolicy::NearestNeighbour &gt;</td></tr>
<tr class="memdesc:ac97f64095bb82d52b499b4eb7623f2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of overloader for nearest neighbour stealing. <br /></td></tr>
<tr class="separator:ac97f64095bb82d52b499b4eb7623f2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08ce9d50dffd50a91c1c92f4b53ea6b"><td class="memItemLeft" align="right" valign="top"><a id="ad08ce9d50dffd50a91c1c92f4b53ea6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ad08ce9d50dffd50a91c1c92f4b53ea6b">TopologicalSteal</a> = <a class="el" href="structVoxx_1_1Conky_1_1ThreadPool_1_1StealOverloader.html">StealOverloader</a>&lt; StealPolicy::Topological &gt;</td></tr>
<tr class="memdesc:ad08ce9d50dffd50a91c1c92f4b53ea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of overloader for topological stealing. <br /></td></tr>
<tr class="separator:ad08ce9d50dffd50a91c1c92f4b53ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3ea01dcd3f395c76225fb2d4982faeed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a3ea01dcd3f395c76225fb2d4982faeed">runnable</a> (std::size_t workerId) const noexcept</td></tr>
<tr class="memdesc:a3ea01dcd3f395c76225fb2d4982faeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a worker thread with <code>workerId</code> to check if it must still run.  <a href="#a3ea01dcd3f395c76225fb2d4982faeed">More...</a><br /></td></tr>
<tr class="separator:a3ea01dcd3f395c76225fb2d4982faeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5293f196b6d53fb76105ff11141bf739"><td class="memItemLeft" align="right" valign="top"><a id="a5293f196b6d53fb76105ff11141bf739"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a5293f196b6d53fb76105ff11141bf739">createWorkers</a> (std::size_t numThreads)</td></tr>
<tr class="memdesc:a5293f196b6d53fb76105ff11141bf739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the worker threads. <br /></td></tr>
<tr class="separator:a5293f196b6d53fb76105ff11141bf739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156d5942b00d229c41915c94cfbc64c"><td class="memItemLeft" align="right" valign="top"><a id="ad156d5942b00d229c41915c94cfbc64c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ad156d5942b00d229c41915c94cfbc64c">makeWorkersRunnable</a> () noexcept</td></tr>
<tr class="memdesc:ad156d5942b00d229c41915c94cfbc64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the worker flags to enable them to start running. <br /></td></tr>
<tr class="separator:ad156d5942b00d229c41915c94cfbc64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf67028a501af41702b50c666ee8a4ce"><td class="memItemLeft" align="right" valign="top"><a id="acf67028a501af41702b50c666ee8a4ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#acf67028a501af41702b50c666ee8a4ce">join</a> () noexcept</td></tr>
<tr class="memdesc:acf67028a501af41702b50c666ee8a4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins the threads. <br /></td></tr>
<tr class="separator:acf67028a501af41702b50c666ee8a4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04db1c102afea56bd8e91c43a88ae34b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a04db1c102afea56bd8e91c43a88ae34b">restartThreads</a> ()</td></tr>
<tr class="memdesc:a04db1c102afea56bd8e91c43a88ae34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts the threads.  <a href="#a04db1c102afea56bd8e91c43a88ae34b">More...</a><br /></td></tr>
<tr class="separator:a04db1c102afea56bd8e91c43a88ae34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224ea04d1be262820d942f781353e69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a224ea04d1be262820d942f781353e69d">process</a> (std::size_t workerId)</td></tr>
<tr class="memdesc:a224ea04d1be262820d942f781353e69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes tasks using the <code>workerId</code> thread and the <code>workerId</code> worker.  <a href="#a224ea04d1be262820d942f781353e69d">More...</a><br /></td></tr>
<tr class="separator:a224ea04d1be262820d942f781353e69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dadf2d25521153dc53dae7a7f06cbb"><td class="memItemLeft" align="right" valign="top"><a id="a13dadf2d25521153dc53dae7a7f06cbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a13dadf2d25521153dc53dae7a7f06cbb">processImpl</a> (std::size_t workerId)</td></tr>
<tr class="memdesc:a13dadf2d25521153dc53dae7a7f06cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process function for the controller thread. <br /></td></tr>
<tr class="separator:a13dadf2d25521153dc53dae7a7f06cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622696b6cfc49ad93a79cab5c6aeab26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a622696b6cfc49ad93a79cab5c6aeab26">steal</a> (std::size_t workerId, <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a310b6404eb1992a2d2bd6ef3b9d0479e">RandomSteal</a> tag)</td></tr>
<tr class="memdesc:a622696b6cfc49ad93a79cab5c6aeab26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the implemenation of the stealing method when the stealing policy is to steal randomly from a task queue from anoter thread.  <a href="#a622696b6cfc49ad93a79cab5c6aeab26">More...</a><br /></td></tr>
<tr class="separator:a622696b6cfc49ad93a79cab5c6aeab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ba93f24dae63fa4361b01bc970d4a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ab9ba93f24dae63fa4361b01bc970d4a6">steal</a> (std::size_t workerId, <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ac97f64095bb82d52b499b4eb7623f2cf">NNeighbourSteal</a> tag)</td></tr>
<tr class="memdesc:ab9ba93f24dae63fa4361b01bc970d4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the implemenation of the stealing method when the stealing policy is to steal from the nearest neighbour.  <a href="#ab9ba93f24dae63fa4361b01bc970d4a6">More...</a><br /></td></tr>
<tr class="separator:ab9ba93f24dae63fa4361b01bc970d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac3e5ea78b072c672896ea4c0bbc3dd64"><td class="memItemLeft" align="right" valign="top"><a id="ac3e5ea78b072c672896ea4c0bbc3dd64"></a>
<a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#acdc979c231259442c770d1a4eef8709d">FlagContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ac3e5ea78b072c672896ea4c0bbc3dd64">Flags</a></td></tr>
<tr class="memdesc:ac3e5ea78b072c672896ea4c0bbc3dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to control the workers. <br /></td></tr>
<tr class="separator:ac3e5ea78b072c672896ea4c0bbc3dd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391a28760a2639e432f63e4bfe68d391"><td class="memItemLeft" align="right" valign="top"><a id="a391a28760a2639e432f63e4bfe68d391"></a>
<a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a58e403696928c7b974efb78c4e628b88">ThreadContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a391a28760a2639e432f63e4bfe68d391">Threads</a></td></tr>
<tr class="memdesc:a391a28760a2639e432f63e4bfe68d391"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threads for the pool. <br /></td></tr>
<tr class="separator:a391a28760a2639e432f63e4bfe68d391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2afd11f433203a5408138b610729df1"><td class="memItemLeft" align="right" valign="top"><a id="ac2afd11f433203a5408138b610729df1"></a>
<a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#acf2725de2ad08dfa205e1055394c17a5">QueueContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ac2afd11f433203a5408138b610729df1">TaskQueues</a></td></tr>
<tr class="memdesc:ac2afd11f433203a5408138b610729df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The queues of tasks for each thread. <br /></td></tr>
<tr class="separator:ac2afd11f433203a5408138b610729df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ab6ccf74a5181e5c0b284abcf3be7f66d"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ab6ccf74a5181e5c0b284abcf3be7f66d">queueAlignment</a></td></tr>
<tr class="memdesc:ab6ccf74a5181e5c0b284abcf3be7f66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of the alignment for the tasks queues.  <a href="#ab6ccf74a5181e5c0b284abcf3be7f66d">More...</a><br /></td></tr>
<tr class="separator:ab6ccf74a5181e5c0b284abcf3be7f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt;<br />
class Voxx::Conky::ThreadPool&lt; TasksPerQueue, Policy, TaskAlignment &gt;</h3>

<p>The <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html" title="The ThreadPool class creates a thread pool with one controlling thread (which may be extended to be a...">ThreadPool</a> class creates a thread pool with one controlling thread (which may be extended to be an interruptible worker thread) and (N - 1) worker threads, wher N is the total number of threads in the pool. </p>
<p>There is a pool of tasks for each of the threads, including the controller thread. If a thread's task queue is empty, it will try and steal from another thread's pool of tasks.</p>
<p>The following is a list of features to be added:</p>
<ol type="1">
<li>Support for yielding and interrupting a task based on priority, without incurring a context switch.</li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TasksPerQueue</td><td>The maximum number of tasks which can be stored in each of the queues owned by a thread. </td></tr>
    <tr><td class="paramname">TaskAlignemnt</td><td>The number of bytes to align each task to. This should be a multiple of the cache line size. The default is two cache lines as this is usually enough space for task arguments. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a727edbad33f2f019ef1ea0d6931ec262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727edbad33f2f019ef1ea0d6931ec262">&#9670;&nbsp;</a></span>ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::<a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">ThreadPool</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor &ndash; creates <code>numThreads</code> - 1 threads and starts processing tasks on them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numThreads</td><td>The number of threads in the pool, including the manager thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e711954f70e25be86d01b32562d12e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e711954f70e25be86d01b32562d12e3">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the thread pool has no more work, otherwise it returns false. </p>

</div>
</div>
<a id="a224ea04d1be262820d942f781353e69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224ea04d1be262820d942f781353e69d">&#9670;&nbsp;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::process </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>workerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes tasks using the <code>workerId</code> thread and the <code>workerId</code> worker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The index to assign to the thread, and which identifies the worker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04db1c102afea56bd8e91c43a88ae34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04db1c102afea56bd8e91c43a88ae34b">&#9670;&nbsp;</a></span>restartThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::restartThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restarts the threads. </p>
<p>This shutsdown the thread, and then joins it before createing a new thread in the place of the old thread. It's designed to be safe, and is not expected that the pool's threads should be started and stopped often. </p>

</div>
</div>
<a id="a3ea01dcd3f395c76225fb2d4982faeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea01dcd3f395c76225fb2d4982faeed">&#9670;&nbsp;</a></span>runnable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::runnable </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>workerId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows a worker thread with <code>workerId</code> to check if it must still run. </p>
<dl class="section note"><dt>Note</dt><dd>Worker threads can only read their state, so the state controllers are not atomic. </dd></dl>

</div>
</div>
<a id="a0159256530cb47af45cf42a848109e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0159256530cb47af45cf42a848109e46">&#9670;&nbsp;</a></span>runningThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::runningThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of threads which are running. </p>
<p>This will always return a value of 1 or greater since the main/manager thread is alwasy running. </p>

</div>
</div>
<a id="a2c219ac4227a19f806110246c349f561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c219ac4227a19f806110246c349f561">&#9670;&nbsp;</a></span>startThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::startThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the threads running. </p>
<p>This ensures that a worker thread is not running before creating another thread in its place. If the thread is running and has not been set to stop running, it's left to run. If it's been set to stop running and is still running, then it's set to stop, and waited on until it finishes, and a new thread is created in its place. </p>

</div>
</div>
<a id="a622696b6cfc49ad93a79cab5c6aeab26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622696b6cfc49ad93a79cab5c6aeab26">&#9670;&nbsp;</a></span>steal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::steal </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>workerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#a310b6404eb1992a2d2bd6ef3b9d0479e">RandomSteal</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the implemenation of the stealing method when the stealing policy is to steal randomly from a task queue from anoter thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">workerId</td><td>The id of the worker which is stealing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag used to select this overload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9ba93f24dae63fa4361b01bc970d4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ba93f24dae63fa4361b01bc970d4a6">&#9670;&nbsp;</a></span>steal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::steal </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>workerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html#ac97f64095bb82d52b499b4eb7623f2cf">NNeighbourSteal</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the implemenation of the stealing method when the stealing policy is to steal from the nearest neighbour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">workerId</td><td>The id of the worker which is stealing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag used to select this overload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc541275693b3cd0b99759ef2802a511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc541275693b3cd0b99759ef2802a511">&#9670;&nbsp;</a></span>tryPush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<div class="memtemplate">
template&lt;typename TaskCallable , typename... TaskArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::tryPush </td>
          <td>(</td>
          <td class="paramtype">TaskCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to push an object onto the worker queue for the current thread. </p>
<p>If the queue is full, then this will return false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callable</td><td>The callable object to invoke for the task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The arguments for the callable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskCallable</td><td>The type of the callable task object. </td></tr>
    <tr><td class="paramname">TaskArgs</td><td>The types of the rguments for the task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab6ccf74a5181e5c0b284abcf3be7f66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ccf74a5181e5c0b284abcf3be7f66d">&#9670;&nbsp;</a></span>queueAlignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t TasksPerQueue, StealPolicy Policy = StealPolicy::NearestNeighbour, std::size_t TaskAlignment = System::destructiveInterfaceSize() * 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classVoxx_1_1Conky_1_1ThreadPool.html">Voxx::Conky::ThreadPool</a>&lt; TasksPerQueue, Policy, TaskAlignment &gt;::queueAlignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= </div><div class="line">    std::max(TaskAlignment, System::destructiveInterfaceSize())</div></div><!-- fragment -->
<p>Defines the size of the alignment for the tasks queues. </p>
<p>The alignment must be at least that of the tasks in the task queue, and large enough to avoid false sharing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/joker/Voxel/Software/voxelated.github.io/scripts/Conky/include/Voxel/Conky/Container/<a class="el" href="ThreadPool_8hpp_source.html">ThreadPool.hpp</a></li>
</ul>
</div><!-- contents -->
<footer class="page-footer">
  <!--div class="container"-->
    <div class="row">
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
          <h5 class="blue-grey-text text-darken-1"><!-- Main footer content--></h5>
          <p class="blue-grey-text text-darken-1"><!--More content --></p>
        </div>
        <div class="right">
          <h5 class="blue-text text-darken-4"><!--Links --></h5>
        </div>
      </div>
      <div class="col s0 m2 l3">
        <!-- Padding -->
      </div>
    </div>
  </div>
  <div class="footer-copyright">
    <div class="row">
      <div class="col s0 m2 l3">
      </div>
      <div class="col s12 m8 l6">
        <div class="left">
          © 2017 Rob Clucas
        </div>
        <div class="right">
          <a class="grey-text text-lighten-4" href="#!"><!--More links--></a>
        </div>
      </div>
      <div class="col s0 m2 l3">
      </div>
    </div>
  </div>
  <!--/div-->
</footer>
